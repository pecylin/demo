(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.range = exports.getTextData = exports.getImageData = exports.getCanvasImageData = exports.addParticlesFromCanvasPixels = exports.shuffle = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    function shuffle(array) {
        for (let currentIndex = array.length - 1; currentIndex >= 0; currentIndex--) {
            const randomIndex = Math.floor((0, tsparticles_engine_1.getRandom)() * currentIndex);
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }
    exports.shuffle = shuffle;
    function addParticlesFromCanvasPixels(container, data, position, scale, override, filter) {
        const { height, width } = data, numPixels = height * width, indexArray = shuffle((0, exports.range)(numPixels)), maxParticles = Math.min(numPixels, container.actualOptions.particles.number.value), canvasSize = container.canvas.size;
        let selectedPixels = 0;
        const positionOffset = {
            x: (canvasSize.width * position.x) / 100 - (width * scale) / 2,
            y: (canvasSize.height * position.y) / 100 - (height * scale) / 2,
        };
        while (selectedPixels < maxParticles && indexArray.length) {
            const nextIndex = indexArray.pop() || 0, pixelPos = {
                x: nextIndex % width,
                y: Math.floor(nextIndex / width),
            }, pixel = data.pixels[pixelPos.y][pixelPos.x], shouldCreateParticle = filter(pixel);
            if (shouldCreateParticle) {
                const pos = {
                    x: pixelPos.x * scale + positionOffset.x,
                    y: pixelPos.y * scale + positionOffset.y,
                };
                const pOptions = {};
                if (override.color) {
                    pOptions.color = {
                        value: pixel,
                    };
                }
                if (override.opacity) {
                    pOptions.opacity = {
                        value: pixel.a,
                    };
                }
                container.particles.addParticle(pos, pOptions);
                selectedPixels++;
            }
        }
    }
    exports.addParticlesFromCanvasPixels = addParticlesFromCanvasPixels;
    function getCanvasImageData(ctx, size, offset, clear = true) {
        const imageData = ctx.getImageData(0, 0, size.width, size.height).data;
        if (clear) {
            ctx.clearRect(0, 0, size.width, size.height);
        }
        const pixels = [];
        for (let i = 0; i < imageData.length; i += offset) {
            const idx = i / offset, pos = {
                x: idx % size.width,
                y: Math.floor(idx / size.width),
            };
            if (!pixels[pos.y]) {
                pixels[pos.y] = [];
            }
            pixels[pos.y][pos.x] = {
                r: imageData[i],
                g: imageData[i + 1],
                b: imageData[i + 2],
                a: imageData[i + 3] / 255,
            };
        }
        return {
            pixels,
            width: Math.min(...pixels.map((row) => row.length)),
            height: pixels.length,
        };
    }
    exports.getCanvasImageData = getCanvasImageData;
    function getImageData(src, offset) {
        const image = new Image();
        image.crossOrigin = "Anonymous";
        const p = new Promise((resolve, reject) => {
            image.onerror = reject;
            image.onload = () => {
                const canvas = document.createElement("canvas");
                canvas.width = image.width;
                canvas.height = image.height;
                const context = canvas.getContext("2d");
                if (!context) {
                    return reject(new Error(`${tsparticles_engine_1.errorPrefix} Could not get canvas context`));
                }
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                resolve(getCanvasImageData(context, canvas, offset));
            };
        });
        image.src = src;
        return p;
    }
    exports.getImageData = getImageData;
    function getTextData(textOptions, offset) {
        const canvas = document.createElement("canvas"), context = canvas.getContext("2d"), { font, text, lines: linesOptions, color } = textOptions;
        if (!text || !context) {
            return;
        }
        const lines = text.split(linesOptions.separator), fontSize = (0, tsparticles_engine_1.isNumber)(font.size) ? `${font.size}px` : font.size, linesData = [];
        let maxWidth = 0, totalHeight = 0;
        for (const line of lines) {
            context.font = `${font.style || ""} ${font.variant || ""} ${font.weight || ""} ${fontSize} ${font.family}`;
            const measure = context.measureText(line), lineData = {
                measure,
                text: line,
                height: measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent,
                width: measure.width,
            };
            maxWidth = Math.max(maxWidth || 0, lineData.width);
            totalHeight += lineData.height + linesOptions.spacing;
            linesData.push(lineData);
        }
        canvas.width = maxWidth;
        canvas.height = totalHeight;
        let currentHeight = 0;
        for (const line of linesData) {
            context.font = `${font.style || ""} ${font.variant || ""} ${font.weight || ""} ${fontSize} ${font.family}`;
            context.fillStyle = color;
            context.fillText(line.text, 0, currentHeight + line.measure.actualBoundingBoxAscent);
            currentHeight += line.height + linesOptions.spacing;
        }
        return getCanvasImageData(context, canvas, offset);
    }
    exports.getTextData = getTextData;
    const range = (n) => [...Array(n).keys()];
    exports.range = range;
});
