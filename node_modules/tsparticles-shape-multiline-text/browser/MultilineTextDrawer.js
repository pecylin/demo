import { executeOnSingleOrMultiple, isInArray, itemFromSingleOrMultiple, loadFont, } from "tsparticles-engine";
export class MultilineTextDrawer {
    constructor() {
        this._drawLine = (context, line, radius, opacity, index, fill) => {
            const offsetX = (line.length * radius) / 2, pos = {
                x: -offsetX,
                y: radius / 2,
            };
            if (fill) {
                context.fillText(line, pos.x, pos.y + radius * 2 * index);
            }
            else {
                context.strokeText(line, pos.x, pos.y + radius * 2 * index);
            }
        };
    }
    draw(context, particle, radius, opacity) {
        const character = particle.shapeData;
        if (character === undefined) {
            return;
        }
        const textData = character.value;
        if (textData === undefined) {
            return;
        }
        if (particle.text === undefined) {
            particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);
        }
        const text = particle.text, style = character.style ?? "", weight = character.weight ?? "400", size = Math.round(radius) * 2, font = character.font ?? "Verdana", fill = particle.fill;
        context.font = `${style} ${weight} ${size}px "${font}"`;
        const lines = text?.split("\n");
        if (!lines) {
            return;
        }
        context.globalAlpha = opacity;
        for (let i = 0; i < lines.length; i++) {
            this._drawLine(context, lines[i], radius, opacity, i, fill);
        }
        context.globalAlpha = 1;
    }
    async init(container) {
        const options = container.options, shapeType = "multiline-text";
        if (isInArray(shapeType, options.particles.shape.type)) {
            const shapeOptions = options.particles.shape.options[shapeType], promises = [];
            executeOnSingleOrMultiple(shapeOptions, (shape) => {
                promises.push(loadFont(shape.font, shape.weight));
            });
            await Promise.all(promises);
        }
    }
    particleInit(container, particle) {
        if (particle.shape !== "multiline-text") {
            return;
        }
        const character = particle.shapeData;
        if (character === undefined) {
            return;
        }
        const textData = character.value;
        if (textData === undefined) {
            return;
        }
        particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);
    }
}
