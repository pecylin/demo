import { Vector, getRandom } from "tsparticles-engine";
import { makeNoise4D } from "./simplex";
export class SimplexNoiseGenerator {
    constructor() {
        this._calculateField = () => {
            for (let x = 0; x < this.options.columns; x++) {
                for (let y = 0; y < this.options.rows; y++) {
                    for (let z = 0; z < this.options.layers; z++) {
                        this.field[x][y][z][0] = this.noiseFunc(x / 50, y / 50, z / 50, this.noiseW) * Math.PI * 2;
                        this.field[x][y][z][1] = this.noiseFunc(x / 100 + 40000, y / 100 + 40000, z / 100 + 40000, this.noiseW);
                    }
                }
            }
        };
        this._initField = () => {
            this.field = new Array(this.options.columns);
            for (let x = 0; x < this.options.columns; x++) {
                this.field[x] = new Array(this.options.rows);
                for (let y = 0; y < this.options.rows; y++) {
                    this.field[x][y] = new Array(this.options.layers);
                    for (let z = 0; z < this.options.layers; z++) {
                        this.field[x][y][z] = [0, 0];
                    }
                }
            }
        };
        this._resetField = (container) => {
            const sourceOptions = container.actualOptions.particles.move.path.options;
            this.options.size = sourceOptions.size > 0 ? sourceOptions.size : 20;
            this.options.increment = sourceOptions.increment > 0 ? sourceOptions.increment : 0.004;
            this.options.width = container.canvas.size.width;
            this.options.height = container.canvas.size.height;
            this.noiseFunc = makeNoise4D(sourceOptions.seed ?? getRandom());
            this.options.columns = Math.floor(this.options.width / this.options.size) + 1;
            this.options.rows = Math.floor(this.options.height / this.options.size) + 1;
            this.options.layers = Math.floor(container.zLayers / this.options.size) + 1;
            this._initField();
        };
        this._setup = (container) => {
            this.noiseW = 0;
            this._resetField(container);
            addEventListener("resize", () => this._resetField(container));
        };
        this.field = [];
        this.noiseFunc = makeNoise4D(getRandom());
        this.noiseW = 0;
        this.options = {
            size: 20,
            increment: 0.004,
            columns: 0,
            rows: 0,
            layers: 0,
            width: 0,
            height: 0,
        };
    }
    generate(particle) {
        const pos = particle.getPosition(), point = {
            x: Math.max(Math.floor(pos.x / this.options.size), 0),
            y: Math.max(Math.floor(pos.y / this.options.size), 0),
            z: Math.max(Math.floor(pos.z / this.options.size), 0),
        }, v = Vector.origin;
        if (!this.field ||
            !this.field[point.x] ||
            !this.field[point.x][point.y] ||
            !this.field[point.x][point.y][point.z]) {
            return v;
        }
        v.length = this.field[point.x][point.y][point.z][1];
        v.angle = this.field[point.x][point.y][point.z][0];
        return v;
    }
    init(container) {
        this.container = container;
        this._setup(this.container);
    }
    reset() {
    }
    update() {
        if (!this.container) {
            return;
        }
        this._calculateField();
        this.noiseW += this.options.increment;
    }
}
