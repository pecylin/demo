(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine", "./Options/Classes/ParticlesRepulse"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Repulser = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    const ParticlesRepulse_1 = require("./Options/Classes/ParticlesRepulse");
    class Repulser extends tsparticles_engine_1.ParticlesInteractorBase {
        constructor(container) {
            super(container);
        }
        clear() {
        }
        init() {
        }
        async interact(p1) {
            const container = this.container;
            if (!p1.repulse) {
                const repulseOpt1 = p1.options.repulse;
                if (!repulseOpt1) {
                    return;
                }
                p1.repulse = {
                    distance: (0, tsparticles_engine_1.getRangeValue)(repulseOpt1.distance) * container.retina.pixelRatio,
                    speed: (0, tsparticles_engine_1.getRangeValue)(repulseOpt1.speed),
                    factor: (0, tsparticles_engine_1.getRangeValue)(repulseOpt1.factor),
                };
            }
            const pos1 = p1.getPosition(), query = container.particles.quadTree.queryCircle(pos1, p1.repulse.distance);
            for (const p2 of query) {
                if (p1 === p2 || p2.destroyed) {
                    continue;
                }
                const pos2 = p2.getPosition();
                const { dx, dy, distance } = (0, tsparticles_engine_1.getDistances)(pos2, pos1);
                const velocity = p1.repulse.speed * p1.repulse.factor;
                if (distance > 0) {
                    const repulseFactor = (0, tsparticles_engine_1.clamp)((1 - Math.pow(distance / p1.repulse.distance, 2)) * velocity, 0, velocity);
                    const normVec = tsparticles_engine_1.Vector.create((dx / distance) * repulseFactor, (dy / distance) * repulseFactor);
                    p2.position.addTo(normVec);
                }
                else {
                    const velocityVec = tsparticles_engine_1.Vector.create(velocity, velocity);
                    p2.position.addTo(velocityVec);
                }
            }
        }
        isEnabled(particle) {
            return particle.options.repulse?.enabled ?? false;
        }
        loadParticlesOptions(options, ...sources) {
            if (!options.repulse) {
                options.repulse = new ParticlesRepulse_1.ParticlesRepulse();
            }
            for (const source of sources) {
                options.repulse.load(source?.repulse);
            }
        }
        reset() {
        }
    }
    exports.Repulser = Repulser;
});
