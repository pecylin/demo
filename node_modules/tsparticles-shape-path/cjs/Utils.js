"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drawPath = void 0;
function drawPath(ctx, radius, path) {
    ctx.moveTo(path.segments[0].values[0].x * radius, path.segments[0].values[0].y * radius);
    for (let i = 0; i < path.segments.length; i++) {
        const segment = path.segments[i];
        switch (segment.type) {
            case "line":
                ctx.lineTo(segment.values[0].x * radius, segment.values[0].y * radius);
                break;
            case "bezier":
                ctx.bezierCurveTo(segment.values[1].x * radius, segment.values[1].y * radius, segment.values[2].x * radius, segment.values[2].y * radius, segment.values[3].x * radius, segment.values[3].y * radius);
                break;
            case "quadratic":
                ctx.quadraticCurveTo(segment.values[1].x * radius, segment.values[1].y * radius, segment.values[2].x * radius, segment.values[2].y * radius);
                break;
            case "arc":
                ctx.arc(segment.values[0].x * radius, segment.values[0].y * radius, segment.values[1].x * radius, segment.values[2].x, segment.values[2].y);
                break;
            case "ellipse":
                ctx.ellipse(segment.values[0].x * radius, segment.values[0].y * radius, segment.values[1].x * radius, segment.values[1].y * radius, segment.values[2].x, segment.values[3].x, segment.values[3].y);
        }
    }
    if (!path.half) {
        return;
    }
    for (let i = path.segments.length - 1; i >= 0; i--) {
        const segment = path.segments[i];
        switch (segment.type) {
            case "line":
                ctx.lineTo(segment.values[0].x * -radius, segment.values[0].y * radius);
                break;
            case "bezier":
                ctx.bezierCurveTo(-segment.values[2].x * radius, segment.values[2].y * radius, -segment.values[1].x * radius, segment.values[1].y * radius, -segment.values[0].x * radius, segment.values[0].y * radius);
                break;
            case "quadratic":
                ctx.quadraticCurveTo(-segment.values[1].x * radius, segment.values[1].y * radius, -segment.values[2].x * radius, segment.values[2].y * radius);
                break;
        }
    }
}
exports.drawPath = drawPath;
