/*! For license information please see tsparticles.shape.path.min.js.LICENSE.txt */
!function(e,a){if("object"==typeof exports&&"object"==typeof module)module.exports=a(require("tsparticles-engine"));else if("function"==typeof define&&define.amd)define(["tsparticles-engine"],a);else{var s="object"==typeof exports?a(require("tsparticles-engine")):a(e.window);for(var t in s)("object"==typeof exports?exports:e)[t]=s[t]}}(this,(e=>(()=>{"use strict";var a={961:a=>{a.exports=e}},s={};function t(e){var r=s[e];if(void 0!==r)return r.exports;var l=s[e]={exports:{}};return a[e](l,l.exports,t),l.exports}t.d=(e,a)=>{for(var s in a)t.o(a,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:a[s]})},t.o=(e,a)=>Object.prototype.hasOwnProperty.call(e,a),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{t.r(r),t.d(r,{loadPathShape:()=>s});var e=t(961);class a{draw(e,a,s){a.pathData&&function(e,a,s){e.moveTo(s.segments[0].values[0].x*a,s.segments[0].values[0].y*a);for(let t=0;t<s.segments.length;t++){const r=s.segments[t];switch(r.type){case"line":e.lineTo(r.values[0].x*a,r.values[0].y*a);break;case"bezier":e.bezierCurveTo(r.values[1].x*a,r.values[1].y*a,r.values[2].x*a,r.values[2].y*a,r.values[3].x*a,r.values[3].y*a);break;case"quadratic":e.quadraticCurveTo(r.values[1].x*a,r.values[1].y*a,r.values[2].x*a,r.values[2].y*a);break;case"arc":e.arc(r.values[0].x*a,r.values[0].y*a,r.values[1].x*a,r.values[2].x,r.values[2].y);break;case"ellipse":e.ellipse(r.values[0].x*a,r.values[0].y*a,r.values[1].x*a,r.values[1].y*a,r.values[2].x,r.values[3].x,r.values[3].y)}}if(s.half)for(let t=s.segments.length-1;t>=0;t--){const r=s.segments[t];switch(r.type){case"line":e.lineTo(r.values[0].x*-a,r.values[0].y*a);break;case"bezier":e.bezierCurveTo(-r.values[2].x*a,r.values[2].y*a,-r.values[1].x*a,r.values[1].y*a,-r.values[0].x*a,r.values[0].y*a);break;case"quadratic":e.quadraticCurveTo(-r.values[1].x*a,r.values[1].y*a,-r.values[2].x*a,r.values[2].y*a)}}}(e,s,a.pathData)}particleInit(a,s){const t=s.shapeData;t&&(s.pathData=(0,e.deepExtend)({},t))}}async function s(e,s=!0){await e.addShape("path",new a,s)}})(),r})()));