/*! For license information please see tsparticles.interaction.light.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("tsparticles-engine"));else if("function"==typeof define&&define.amd)define(["tsparticles-engine"],e);else{var o="object"==typeof exports?e(require("tsparticles-engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{"use strict";var e={961:e=>{e.exports=t}},o={};function i(t){var r=o[t];if(void 0!==r)return r.exports;var s=o[t]={exports:{}};return e[t](s,s.exports,i),s.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{i.r(r),i.d(r,{Light:()=>n,LightArea:()=>o,LightGradient:()=>e,LightShadow:()=>s,loadLightInteraction:()=>l});var t=i(961);class e{constructor(){this.start=new t.OptionsColor,this.stop=new t.OptionsColor,this.start.value="#ffffff",this.stop.value="#000000"}load(e){e&&(this.start=t.OptionsColor.create(this.start,e.start),this.stop=t.OptionsColor.create(this.stop,e.stop))}}class o{constructor(){this.gradient=new e,this.radius=1e3}load(t){t&&(this.gradient.load(t.gradient),void 0!==t.radius&&(this.radius=t.radius))}}class s{constructor(){this.color=new t.OptionsColor,this.color.value="#000000",this.length=2e3}load(e){e&&(this.color=t.OptionsColor.create(this.color,e.color),void 0!==e.length&&(this.length=e.length))}}class n{constructor(){this.area=new o,this.shadow=new s}load(t){t&&(this.area.load(t.area),this.shadow.load(t.shadow))}}class a extends t.ExternalInteractorBase{constructor(t){super(t)}clear(){}init(){}async interact(){const e=this.container,o=e.actualOptions,i=e.interactivity;if(!o.interactivity.events.onHover.enable||"pointermove"!==i.status)return;const r=i.mouse.position;r&&e.canvas.draw((o=>{!function(e,o,i){const r=e.actualOptions.interactivity.modes.light?.area;if(!r)return;o.beginPath(),o.arc(i.x,i.y,r.radius,0,2*Math.PI);const s=o.createRadialGradient(i.x,i.y,0,i.x,i.y,r.radius),n=e.canvas.mouseLight;n&&n.start&&n.stop&&(s.addColorStop(0,(0,t.getStyleFromRgb)(n.start)),s.addColorStop(1,(0,t.getStyleFromRgb)(n.stop)),o.fillStyle=s,o.fill())}(e,o,r)}))}isEnabled(e){const o=this.container,i=o.interactivity.mouse,r=e?.interactivity??o.actualOptions.interactivity,s=r.events;if(!s.onHover.enable||!i.position)return!1;const n=(0,t.isInArray)("light",s.onHover.mode);if(n&&r.modes.light){const e=r.modes.light.area.gradient;o.canvas.mouseLight={start:(0,t.rangeColorToRgb)(e.start),stop:(0,t.rangeColorToRgb)(e.stop)}}return n}loadModeOptions(t,...e){t.light||(t.light=new n);for(const o of e)t.light.load(o?.light)}reset(){}}class c extends t.ParticlesInteractorBase{constructor(t){super(t)}clear(){}init(){}async interact(e){const o=this.container,i=o.actualOptions,r=o.interactivity;if(!i.interactivity.events.onHover.enable||"pointermove"!==r.status)return;const s=r.mouse.position;s&&o.canvas.draw((i=>{!function(e,o,i,r){const s=i.getPosition(),n=e.actualOptions.interactivity.modes.light?.shadow;if(!n)return;const a=i.lightShadow;if(!a)return;const c=i.getRadius(),l=i.sides,d=2*Math.PI/l,h=-i.rotation+Math.PI/4,u=[];for(let t=0;t<l;t++)u.push({x:s.x+c*Math.sin(h+d*t)*1,y:s.y+c*Math.cos(h+d*t)*1});const p=[],g=n.length;for(const t of u){const e=Math.atan2(r.y-t.y,r.x-t.x),o={x:t.x+g*Math.sin(-e-Math.PI/2),y:t.y+g*Math.cos(-e-Math.PI/2)};p.push({end:o,start:t})}const f=(0,t.getStyleFromRgb)(a);for(let t=p.length-1,e=0;t>=0;e=t--)o.beginPath(),o.moveTo(p[t].start.x,p[t].start.y),o.lineTo(p[e].start.x,p[e].start.y),o.lineTo(p[e].end.x,p[e].end.y),o.lineTo(p[t].end.x,p[t].end.y),o.fillStyle=f,o.fill()}(o,i,e,s)}))}isEnabled(e){const o=this.container,i=e.interactivity??o.actualOptions.interactivity,r=o.interactivity.mouse,s=i.events;if(!s.onHover.enable||!r.position)return!1;const n=(0,t.isInArray)("light",s.onHover.mode);if(n&&i.modes.light){const o=i.modes.light.shadow;e.lightShadow=(0,t.rangeColorToRgb)(o.color)}return n}reset(){}}async function l(t,e=!0){await t.addInteractor("externalLight",(t=>new a(t)),e),await t.addInteractor("particlesLight",(t=>new c(t)),e)}})(),r})()));