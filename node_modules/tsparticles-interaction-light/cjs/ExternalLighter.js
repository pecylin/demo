"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalLighter = void 0;
const tsparticles_engine_1 = require("tsparticles-engine");
const Light_1 = require("./Options/Classes/Light");
const Utils_1 = require("./Utils");
class ExternalLighter extends tsparticles_engine_1.ExternalInteractorBase {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
    }
    async interact() {
        const container = this.container, options = container.actualOptions, interactivity = container.interactivity;
        if (!options.interactivity.events.onHover.enable || interactivity.status !== "pointermove") {
            return;
        }
        const mousePos = interactivity.mouse.position;
        if (!mousePos) {
            return;
        }
        container.canvas.draw((ctx) => {
            (0, Utils_1.drawLight)(container, ctx, mousePos);
        });
    }
    isEnabled(particle) {
        const container = this.container, mouse = container.interactivity.mouse, interactivity = particle?.interactivity ?? container.actualOptions.interactivity, events = interactivity.events;
        if (!(events.onHover.enable && mouse.position)) {
            return false;
        }
        const res = (0, tsparticles_engine_1.isInArray)("light", events.onHover.mode);
        if (res && interactivity.modes.light) {
            const lightGradient = interactivity.modes.light.area.gradient;
            container.canvas.mouseLight = {
                start: (0, tsparticles_engine_1.rangeColorToRgb)(lightGradient.start),
                stop: (0, tsparticles_engine_1.rangeColorToRgb)(lightGradient.stop),
            };
        }
        return res;
    }
    loadModeOptions(options, ...sources) {
        if (!options.light) {
            options.light = new Light_1.Light();
        }
        for (const source of sources) {
            options.light.load(source?.light);
        }
    }
    reset() {
    }
}
exports.ExternalLighter = ExternalLighter;
