"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerlinNoiseGenerator = void 0;
const tsparticles_engine_1 = require("tsparticles-engine");
const PerlinNoise_1 = require("./PerlinNoise");
class PerlinNoiseGenerator {
    constructor() {
        this._calculateField = () => {
            const { field, noiseGen, options } = this;
            for (let x = 0; x < options.columns; x++) {
                const column = field[x];
                for (let y = 0; y < options.rows; y++) {
                    const cell = column[y];
                    cell.length = noiseGen.noise(x / 100 + 40000, y / 100 + 40000, this.noiseZ);
                    cell.angle = noiseGen.noise(x / 50, y / 50, this.noiseZ) * Math.PI * 2;
                }
            }
        };
        this._drawField = (ctx) => {
            const { field, options } = this;
            for (let x = 0; x < options.columns; x++) {
                const column = field[x];
                for (let y = 0; y < options.rows; y++) {
                    const cell = column[y], { angle, length } = cell;
                    ctx.setTransform(1, 0, 0, 1, x * this.options.size, y * this.options.size);
                    ctx.rotate(angle);
                    ctx.strokeStyle = "white";
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, this.options.size * length);
                    ctx.stroke();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }
            }
        };
        this._initField = () => {
            const { columns, rows } = this.options;
            this.field = new Array(columns);
            for (let x = 0; x < columns; x++) {
                this.field[x] = new Array(rows);
                for (let y = 0; y < rows; y++) {
                    this.field[x][y] = tsparticles_engine_1.Vector.origin;
                }
            }
        };
        this._resetField = (container) => {
            const sourceOptions = container.actualOptions.particles.move.path.options, { options } = this;
            options.size = sourceOptions.size > 0 ? sourceOptions.size : 20;
            options.increment = sourceOptions.increment > 0 ? sourceOptions.increment : 0.004;
            options.draw = !!sourceOptions.draw;
            options.width = container.canvas.size.width;
            options.height = container.canvas.size.height;
            this.noiseGen.seed(sourceOptions.seed ?? (0, tsparticles_engine_1.getRandom)());
            options.columns = Math.floor(this.options.width / this.options.size) + 1;
            options.rows = Math.floor(this.options.height / this.options.size) + 1;
            this._initField();
        };
        this._setup = (container) => {
            this.noiseZ = 0;
            this._resetField(container);
            window.addEventListener("resize", () => this._resetField(container));
        };
        this.noiseGen = new PerlinNoise_1.PerlinNoise();
        this.field = [];
        this.noiseZ = 0;
        this.options = {
            draw: false,
            size: 20,
            increment: 0.004,
            columns: 0,
            rows: 0,
            width: 0,
            height: 0,
        };
    }
    generate(particle) {
        const pos = particle.getPosition(), { size } = this.options, point = {
            x: Math.max(Math.floor(pos.x / size), 0),
            y: Math.max(Math.floor(pos.y / size), 0),
        }, { field } = this;
        return !field || !field[point.x] || !field[point.x][point.y] ? tsparticles_engine_1.Vector.origin : field[point.x][point.y].copy();
    }
    init(container) {
        this.container = container;
        this._setup(container);
    }
    reset() {
    }
    update() {
        if (!this.container) {
            return;
        }
        this._calculateField();
        this.noiseZ += this.options.increment;
        if (this.options.draw) {
            this.container.canvas.draw((ctx) => this._drawField(ctx));
        }
    }
}
exports.PerlinNoiseGenerator = PerlinNoiseGenerator;
