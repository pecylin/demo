/*! For license information please see tsparticles.updater.gradient.min.js.LICENSE.txt */
!function(e,a){if("object"==typeof exports&&"object"==typeof module)module.exports=a(require("tsparticles-engine"));else if("function"==typeof define&&define.amd)define(["tsparticles-engine"],a);else{var t="object"==typeof exports?a(require("tsparticles-engine")):a(e.window);for(var i in t)("object"==typeof exports?exports:e)[i]=t[i]}}(this,(e=>(()=>{"use strict";var a={961:a=>{a.exports=e}},t={};function i(e){var n=t[e];if(void 0!==n)return n.exports;var o=t[e]={exports:{}};return a[e](o,o.exports,i),o.exports}i.d=(e,a)=>{for(var t in a)i.o(a,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:a[t]})},i.o=(e,a)=>Object.prototype.hasOwnProperty.call(e,a),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{i.r(n),i.d(n,{loadGradientUpdater:()=>y});var e=i(961);class a{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1,this.startValue="random"}load(a){a&&(void 0!==a.count&&(this.count=(0,e.setRangeValue)(a.count)),void 0!==a.enable&&(this.enable=a.enable),void 0!==a.speed&&(this.speed=(0,e.setRangeValue)(a.speed)),void 0!==a.sync&&(this.sync=a.sync),void 0!==a.startValue&&(this.startValue=a.startValue),void 0!==a.decay&&(this.decay=(0,e.setRangeValue)(a.decay)),void 0!==a.delay&&(this.delay=(0,e.setRangeValue)(a.delay)))}}class t{constructor(){this.value=0,this.animation=new a}load(a){a&&(this.animation.load(a.animation),void 0!==a.value&&(this.value=(0,e.setRangeValue)(a.value)))}}class o{constructor(){this.stop=0,this.value=new e.AnimatableColor}load(a){a&&(void 0!==a.stop&&(this.stop=a.stop),this.value=e.AnimatableColor.create(this.value,a.value),void 0!==a.opacity&&(this.opacity=new t,(0,e.isNumber)(a.opacity)?this.opacity.value=a.opacity:this.opacity.load(a.opacity)))}}class s{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1}load(a){a&&(void 0!==a.count&&(this.count=(0,e.setRangeValue)(a.count)),void 0!==a.enable&&(this.enable=a.enable),void 0!==a.speed&&(this.speed=(0,e.setRangeValue)(a.speed)),void 0!==a.decay&&(this.decay=(0,e.setRangeValue)(a.decay)),void 0!==a.delay&&(this.delay=(0,e.setRangeValue)(a.delay)),void 0!==a.sync&&(this.sync=a.sync))}}class l{constructor(){this.value=0,this.animation=new s,this.direction="clockwise"}load(a){a&&(this.animation.load(a.animation),void 0!==a.value&&(this.value=(0,e.setRangeValue)(a.value)),void 0!==a.direction&&(this.direction=a.direction))}}class c{constructor(){this.angle=new l,this.colors=[],this.type="random"}load(e){e&&(this.angle.load(e.angle),void 0!==e.colors&&(this.colors=e.colors.map((e=>{const a=new o;return a.load(e),a}))),void 0!==e.type&&(this.type=e.type))}}function r(e,a){if(!a.enable)return;const t=a.decay??1;switch(a.status){case"increasing":a.value>=a.max?a.status="decreasing":a.value+=(a.velocity??0)*e.factor;break;case"decreasing":a.value<=a.min?a.status="increasing":a.value-=(a.velocity??0)*e.factor}a.velocity&&1!==t&&(a.velocity*=t)}function u(e,a,t,i){if(!a||!a.enable)return;if(a.time||(a.time=0),(a.delayTime??0)>0&&a.time<(a.delayTime??0)&&(a.time+=e.value),(a.delayTime??0)>0&&a.time<(a.delayTime??0))return;const n=(a.velocity??0)*e.factor,o=a.decay??1;i&&"increasing"!==a.status?(a.value-=n,a.value<0&&(a.status="increasing",a.value+=a.value)):(a.value+=n,i&&a.value>t&&(a.status="decreasing",a.value-=a.value%t)),a.value>t&&(a.value%=t),a.velocity&&1!==o&&(a.velocity*=o)}function d(e,a){const{gradient:t}=e;if(t){!function(e,a){const t=(a.velocity??0)*e.factor,i=2*Math.PI,n=a.decay??1;a.enable&&("increasing"===a.status?(a.value+=t,a.value>i&&(a.value-=i)):(a.value-=t,a.value<0&&(a.value+=i)),a.velocity&&1!==n&&(a.velocity*=n))}(a,t.angle);for(const i of t.colors)void 0!==e.color?.h&&u(a,i.value.h,360,!1),void 0!==e.color?.s&&u(a,i.value.s,100,!0),void 0!==e.color?.l&&u(a,i.value.l,100,!0),i.opacity&&r(a,i.opacity)}}class v{getColorStyles(a,t,i,n){const o=a.gradient;if(!o)return{};const s=o.angle.value,l="radial"===o.type?t.createRadialGradient(0,0,0,0,0,i):t.createLinearGradient(Math.cos(s)*-i,Math.sin(s)*-i,Math.cos(s)*i,Math.sin(s)*i);for(const{stop:a,value:t,opacity:i}of o.colors)l.addColorStop(a,(0,e.getStyleFromHsl)({h:t.h.value,s:t.s.value,l:t.l.value},i?.value??n));return{fill:l}}init(a){const t=(0,e.itemFromSingleOrMultiple)(a.options.gradient);if(!t)return;const{angle:i}=t;a.gradient={angle:{value:(0,e.getRangeValue)(i.value),enable:i.animation.enable,velocity:(0,e.getRangeValue)(i.animation.speed)/360*a.container.retina.reduceFactor,decay:1-(0,e.getRangeValue)(i.animation.decay),delayTime:1e3*(0,e.getRangeValue)(i.animation.delay),time:0},type:t.type,colors:[]};let n=t.angle.direction;switch("random"===n&&(n=(0,e.getRandom)()>.5?"counter-clockwise":"clockwise"),n){case"counter-clockwise":case"counterClockwise":a.gradient.angle.status="decreasing";break;case"clockwise":a.gradient.angle.status="increasing"}const o=a.options.reduceDuplicates;for(const i of t.colors){const t=(0,e.rangeColorToHsl)(i.value,a.id,o);if(!t)continue;const n=(0,e.getHslAnimationFromHsl)(t,i.value.animation,a.container.retina.reduceFactor),s={stop:i.stop,value:n,opacity:i.opacity?{enable:i.opacity.animation.enable,max:(0,e.getRangeMax)(i.opacity.value),min:(0,e.getRangeMin)(i.opacity.value),status:"increasing",value:(0,e.getRangeValue)(i.opacity.value),velocity:(0,e.getRangeValue)(i.opacity.animation.speed)/100*a.container.retina.reduceFactor,decay:1-(0,e.getRangeValue)(i.opacity.animation.decay),delayTime:1e3*(0,e.getRangeValue)(i.opacity.animation.delay),time:0}:void 0},{opacity:l}=s;if(i.opacity&&l){const a=i.opacity.value;l.min=(0,e.getRangeMin)(a),l.max=(0,e.getRangeMax)(a);switch(i.opacity.animation.startValue){case"min":l.value=l.min,l.status="increasing";break;case"max":l.value=l.max,l.status="decreasing";break;default:l.value=(0,e.randomInRange)(l),l.status=(0,e.getRandom)()>=.5?"increasing":"decreasing"}}a.gradient.colors.push(s)}}isEnabled(e){return!e.destroyed&&!e.spawning&&(e.gradient?.angle.enable||(e.gradient?.colors.some((e=>e.value.h.enable||e.value.s.enable||e.value.l.enable))??!1))}loadOptions(a,...t){for(const i of t){if(!i?.gradient)continue;const t=i.gradient;t&&(a.gradient=(0,e.executeOnSingleOrMultiple)(t,(e=>{const a=new c;return a.load(e),a})))}}update(e,a){d(e,a)}}async function y(e,a=!0){await e.addParticleUpdater("gradient",(()=>new v),a)}})(),n})()));