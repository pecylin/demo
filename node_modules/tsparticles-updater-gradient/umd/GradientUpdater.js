(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine", "./Options/Classes/AnimatableGradient", "./Utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GradientUpdater = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    const AnimatableGradient_1 = require("./Options/Classes/AnimatableGradient");
    const Utils_1 = require("./Utils");
    class GradientUpdater {
        getColorStyles(particle, context, radius, opacity) {
            const gradient = particle.gradient;
            if (!gradient) {
                return {};
            }
            const gradientAngle = gradient.angle.value, fillGradient = gradient.type === "radial"
                ? context.createRadialGradient(0, 0, 0, 0, 0, radius)
                : context.createLinearGradient(Math.cos(gradientAngle) * -radius, Math.sin(gradientAngle) * -radius, Math.cos(gradientAngle) * radius, Math.sin(gradientAngle) * radius);
            for (const { stop, value, opacity: cOpacity } of gradient.colors) {
                fillGradient.addColorStop(stop, (0, tsparticles_engine_1.getStyleFromHsl)({
                    h: value.h.value,
                    s: value.s.value,
                    l: value.l.value,
                }, cOpacity?.value ?? opacity));
            }
            return { fill: fillGradient };
        }
        init(particle) {
            const gradient = (0, tsparticles_engine_1.itemFromSingleOrMultiple)(particle.options.gradient);
            if (!gradient) {
                return;
            }
            const { angle } = gradient;
            particle.gradient = {
                angle: {
                    value: (0, tsparticles_engine_1.getRangeValue)(angle.value),
                    enable: angle.animation.enable,
                    velocity: ((0, tsparticles_engine_1.getRangeValue)(angle.animation.speed) / 360) * particle.container.retina.reduceFactor,
                    decay: 1 - (0, tsparticles_engine_1.getRangeValue)(angle.animation.decay),
                    delayTime: (0, tsparticles_engine_1.getRangeValue)(angle.animation.delay) * 1000,
                    time: 0,
                },
                type: gradient.type,
                colors: [],
            };
            let rotateDirection = gradient.angle.direction;
            if (rotateDirection === "random") {
                rotateDirection = (0, tsparticles_engine_1.getRandom)() > 0.5 ? "counter-clockwise" : "clockwise";
            }
            switch (rotateDirection) {
                case "counter-clockwise":
                case "counterClockwise":
                    particle.gradient.angle.status = "decreasing";
                    break;
                case "clockwise":
                    particle.gradient.angle.status = "increasing";
                    break;
            }
            const reduceDuplicates = particle.options.reduceDuplicates;
            for (const grColor of gradient.colors) {
                const grHslColor = (0, tsparticles_engine_1.rangeColorToHsl)(grColor.value, particle.id, reduceDuplicates);
                if (!grHslColor) {
                    continue;
                }
                const grHslAnimation = (0, tsparticles_engine_1.getHslAnimationFromHsl)(grHslColor, grColor.value.animation, particle.container.retina.reduceFactor), addColor = {
                    stop: grColor.stop,
                    value: grHslAnimation,
                    opacity: grColor.opacity
                        ? {
                            enable: grColor.opacity.animation.enable,
                            max: (0, tsparticles_engine_1.getRangeMax)(grColor.opacity.value),
                            min: (0, tsparticles_engine_1.getRangeMin)(grColor.opacity.value),
                            status: "increasing",
                            value: (0, tsparticles_engine_1.getRangeValue)(grColor.opacity.value),
                            velocity: ((0, tsparticles_engine_1.getRangeValue)(grColor.opacity.animation.speed) / 100) *
                                particle.container.retina.reduceFactor,
                            decay: 1 - (0, tsparticles_engine_1.getRangeValue)(grColor.opacity.animation.decay),
                            delayTime: (0, tsparticles_engine_1.getRangeValue)(grColor.opacity.animation.delay) * 1000,
                            time: 0,
                        }
                        : undefined,
                };
                const { opacity: addOpacity } = addColor;
                if (grColor.opacity && addOpacity) {
                    const opacityRange = grColor.opacity.value;
                    addOpacity.min = (0, tsparticles_engine_1.getRangeMin)(opacityRange);
                    addOpacity.max = (0, tsparticles_engine_1.getRangeMax)(opacityRange);
                    const opacityAnimation = grColor.opacity.animation;
                    switch (opacityAnimation.startValue) {
                        case "min":
                            addOpacity.value = addOpacity.min;
                            addOpacity.status = "increasing";
                            break;
                        case "max":
                            addOpacity.value = addOpacity.max;
                            addOpacity.status = "decreasing";
                            break;
                        case "random":
                        default:
                            addOpacity.value = (0, tsparticles_engine_1.randomInRange)(addOpacity);
                            addOpacity.status =
                                (0, tsparticles_engine_1.getRandom)() >= 0.5 ? "increasing" : "decreasing";
                            break;
                    }
                }
                particle.gradient.colors.push(addColor);
            }
        }
        isEnabled(particle) {
            return (!particle.destroyed &&
                !particle.spawning &&
                (particle.gradient?.angle.enable ||
                    (particle.gradient?.colors.some((c) => c.value.h.enable || c.value.s.enable || c.value.l.enable) ??
                        false)));
        }
        loadOptions(options, ...sources) {
            for (const source of sources) {
                if (!source?.gradient) {
                    continue;
                }
                const gradientToLoad = source.gradient;
                if (!gradientToLoad) {
                    continue;
                }
                options.gradient = (0, tsparticles_engine_1.executeOnSingleOrMultiple)(gradientToLoad, (gradient) => {
                    const tmp = new AnimatableGradient_1.AnimatableGradient();
                    tmp.load(gradient);
                    return tmp;
                });
            }
        }
        update(particle, delta) {
            (0, Utils_1.updateGradient)(particle, delta);
        }
    }
    exports.GradientUpdater = GradientUpdater;
});
