/*! For license information please see tsparticles.path.curves.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("tsparticles-engine"));else if("function"==typeof define&&define.amd)define(["tsparticles-engine"],t);else{var n="object"==typeof exports?t(require("tsparticles-engine")):t(e.window);for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(this,(e=>(()=>{"use strict";var t={961:t=>{t.exports=e}},n={};function o(e){var r=n[e];if(void 0!==r)return r.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,o),i.exports}o.d=(e,t)=>{for(var n in t)o.o(t,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{o.r(r),o.d(r,{curvesPathName:()=>n,loadCurvesPath:()=>i});var e=o(961);class t{constructor(){this.options={rndFunc:null,period:100,nbHarmonics:2,attenHarmonics:.8,lowValue:-.03,highValue:.03}}generate(t){if(!t.pathGen){const n=this.options;t.pathGen=function(t,n,o,r,i=0,a=1){const c=[],l=[],s=[],u=[],p=[],d=t??e.getRandom;let h=0;o<1&&(o=1);for(let e=1;e<=o;++e)c[e]=d(),l[e]=d(),s[e]=1===e?1:s[e-1]*r,h+=s[e],u[e]=e/n,p[e]=d();return s.forEach(((e,t)=>s[t]=e/h*(a-i))),()=>{let e,t,n=0;for(let r=o;r>=1;--r)e=p[r]+=u[r],p[r]>=1&&(e=p[r]-=1,c[r]=l[r],l[r]=d()),t=e**2*(3-2*e),n+=(c[r]*(1-t)+l[r]*t)*s[r];return n+i}}(n.rndFunc,n.period,n.nbHarmonics,n.attenHarmonics,n.lowValue,n.highValue)}return t.curveVelocity?(t.curveVelocity.length+=.01,t.curveVelocity.angle=(t.curveVelocity.angle+t.pathGen())%(2*Math.PI)):(t.curveVelocity=e.Vector.origin,t.curveVelocity.length=.6*(0,e.getRandom)()+.8,t.curveVelocity.angle=(0,e.getRandom)()*Math.PI*2),t.velocity.x=0,t.velocity.y=0,t.curveVelocity}init(t){const n=t.actualOptions.particles.move.path.options,{options:o}=this;(0,e.isFunction)(n.rndFunc)?o.rndFunc=n.rndFunc:(0,e.isString)(n.rndFunc)&&(o.rndFunc=window[n.rndFunc]||this.options.rndFunc),o.period=n.period??o.period,o.nbHarmonics=n.nbHarmonics??o.nbHarmonics,o.attenHarmonics=n.attenHarmonics??o.attenHarmonics,o.lowValue=n.lowValue??o.lowValue,o.highValue=n.highValue??o.highValue}reset(e){delete e.pathGen,delete e.curveVelocity}update(){}}const n="curvesPathGenerator";async function i(e,o=!0){await e.addPathGenerator(n,new t,o)}})(),r})()));