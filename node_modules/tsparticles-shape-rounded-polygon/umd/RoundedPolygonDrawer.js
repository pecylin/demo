(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RoundedPolygonDrawer = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    function polygon(sides, radius, rot = 0) {
        const step = (Math.PI * 2) / sides, path = [];
        for (let i = 0; i < sides; i++) {
            path.push({ x: Math.cos(i * step + rot) * radius, y: Math.sin(i * step + rot) * radius });
        }
        return path;
    }
    function roundedPath(context, path, radius) {
        let p1 = path[0], p2 = path[1];
        const len = path.length;
        context.moveTo((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
        for (let i = 1; i <= len; i++) {
            p1 = p2;
            p2 = path[(i + 1) % len];
            context.arcTo(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, radius);
        }
    }
    class RoundedPolygonDrawer {
        draw(context, particle, radius) {
            roundedPath(context, polygon(particle.sides, radius), particle.borderRadius ?? 5);
        }
        getSidesCount(particle) {
            const roundedPolygon = particle.shapeData;
            return Math.round((0, tsparticles_engine_1.getRangeValue)(roundedPolygon?.sides ?? 5));
        }
        particleInit(container, particle) {
            const shapeData = particle.shapeData;
            particle.borderRadius = Math.round((0, tsparticles_engine_1.getRangeValue)(shapeData?.radius ?? 5)) * container.retina.pixelRatio;
        }
    }
    exports.RoundedPolygonDrawer = RoundedPolygonDrawer;
});
